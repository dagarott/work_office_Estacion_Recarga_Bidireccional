{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"Vol",
				"VoltageRequest"
			],
			[
				"PsEna",
				"PsEnable_ON"
			],
			[
				"Enable",
				"EnablePs"
			],
			[
				"Actual",
				"ActualVoltageValue"
			],
			[
				"Powe",
				"PowerSupplyValues"
			],
			[
				"Curr",
				"CurrentTarget"
			],
			[
				"Current",
				"CurrentTarget"
			],
			[
				"Power",
				"PowerSupplyValues"
			],
			[
				"V2G",
				"V2G500V15A_CURRENT"
			],
			[
				"cURRE",
				"CurrentRequest"
			],
			[
				"Volta",
				"VoltageRequest"
			],
			[
				"vOLTA",
				"VoltageRequest"
			],
			[
				"Volt",
				"VoltageTarget"
			]
		]
	},
	"buffers":
	[
		{
			"contents": "/**\n * \\file ComModule.c\n * \\brief\n * \\details\n * \\author dagaro\n * \\version 1.0\n * \\date 2018\n * \\pre\n * \\bug\n * \\warning\n * \\copyright ITE\n */\n\n/* USER CODE BEGIN Includes */\n#include \"ComModule.h\"\n/* USER CODE END Includes */\n\n/* USER CODE BEGIN PD */\n/* Private defines -----------------------------------------------------------*/\n#define BitRate 500\n#define MSG_DATA_LENGTH 8\n#define NumMsg 20\n\n/* USER CODE END PD */\n\n/* USER CODE BEGIN PFP */\n/* Private function prototypes -----------------------------------------------*/\nvoid AnalyzeCanMsg(void);\nuint16_t Set_CANOpenErrorMsg_To_Tx(enum Indice_Diccionario_TPO Idx,\n                                   FIFO *ptr_MsgToTx, uint32_t DataToTx,\n                                   uint16_t Idx_Node);\n\nvoid TimeOutRxCanMsg(void);\n\n/* USER CODE END PFP */\n\n/* USER CODE BEGIN PV */\n/* Private variables---------------------------------------------------------*/\nFIFO FIFO_CanTx; //Unique CAN FIFO defined for store CAN tx\nFIFO FIFO_CanRx; //Unique CAN FIFO defined for store CAN rx\nFIFO FIFO_PcRx;  //FIFO Tx defined for Industrial PC\nFIFO FIFO_PcTx;  //FIFO Rx defined for Industrial PC\n\ntCANMsgObject sTX_CANOpenMsg;        //Can message objet for tx\ntCANMsgObject sMailboxOneCANOpenMsg; //Can message object for rx\ntCANMsgObject sMailboxTwoCANOpenMsg; //Can message object for rx\n\nunsigned char rxPsMsgData[8] = {0};  //Array to store data from CAN object\nunsigned char rxAdcMsgData[8] = {0}; //Array to store data from CAN object\n\nvolatile uint32_t ulTimeOutCANRx; //Variable used by function TimeOut\nuint16_t Count1ms = 0;           //Variable used by scheduler\nuint16_t Count10ms = 0;           //Variable used by scheduler\nuint16_t Count20ms = 0;           //Variable used by scheduler\nuint16_t Count50ms = 0;           //Variable used by scheduler\nuint16_t Count100ms = 0;          //Variable used by scheduler\nuint16_t Count200ms = 0;           //Variable used by scheduler\nuint16_t Count500ms = 0;          //Variable used by scheduler\nuint16_t Count1s = 0;             //Variable used by scheduler\nuint16_t Count2s = 0;           //Variable used by scheduler\nuint16_t Count5s = 0;             //Variable used by scheduler\n\ntypedef struct sObjectTx\n{\n    uint16_t OB;      //Last Object Sent with CAN peripheral\n    uint16_t Node_ID; //Id of Node that has sent last Object\n} LastObjectTx_t;\n\nLastObjectTx_t PowerSupply_LastObjectTx = {0x00, 0x00};\n\nAdcValues_t AdcValuesSaved = {0, 0.0, 0, 0.0, 0, 0, 0, 0};\n\nPowerSupplyValues_t PowerSupplyValues = {\" \", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n\nuint16_t CurrentProcess = 0; //\n\n/* USER CODE END PV */\n\n/* USER CODE BEGIN NPV */\n/* Non Private variables ---------------------------------------------------------*/\nenum Indice_Diccionario_TPO OD_Index = FIN_Diccionario;\nFlagsCom_t StatusCom = {0x00};\nFlagsError_t StatusErrors = {0x00};\n/* USER CODE END NPV */\n\n/*-----------------------------------BEGIN MISCELANIOUS FUNCTIONS--------------------------------------*/\n\n/**\n * @brief Makes a new CANOpen FIFO with known values such as length and depth\n * \n */\nvoid Init_CANOpenMsgFIFOs(void)\n{\n\n    //Init_FIFO(&FIFO_PowerSupplyTx, MSG_DATA_LENGTH + 1, NumMsg); // NumWords = ID + MSG_DATA_LENGTH = 9  bytes\n    // ID = 1 byte\n    // MSG_DATA_LENGTH= 8 bytes\n    // NumMsg = Depth of the stack\n    Init_FIFO(&FIFO_CanTx, MSG_DATA_LENGTH + 1, NumMsg); // NumWords = ID + MSG_DATA_LENGTH = 9  bytes\n                                                         // ID = 1 byte\n                                                         // MSG_DATA_LENGTH= 8 bytes\n                                                         // NumMsg = Depth of the stack\n    Init_FIFO(&FIFO_CanRx, MSG_DATA_LENGTH + 1, NumMsg); // Common reception FIFO for ADC and Power Supply\n                                                         // NumWords = ID + MSG_DATA_LENGTH = 9  bytes\n                                                         // ID = 1 byte\n                                                         // MSG_DATA_LENGTH= 8 bytes\n                                                         // NumMsg = Depth of the stack\n}\n/**\n * @brief  Build a message in the correct CANOpen Protocol way and stack it in FIFO,\n *         waiting to be transmitted by CAN peripheral\n * \n * @param Indice_Diccionario_TPO \n * @param ptr_MsgToTx \n * @param DataToTx  \n * @param Access Mode     --> Values could be (0)not apply/write_xbytes/read_xbytres\n *                        There are objects with both mode set, read_xbytes+write_xbytes,\n *                        in dictionary acces mode item, then in order to set correct CAN\n *                        frame is necessary to select one acces mode.\n *                        In the other hand, we also have object with only one mode, then \n *                        reading directly from dictionary acces mode item it is enough\n * @return uint16_t \n */\nuint16_t Set_CANOpenMsg_To_Tx(enum Indice_Diccionario_TPO Idx,\n                              FIFO *ptr_MsgToTx, uint32_t DataToTx,\n                              uint16_t Idx_Node, uint8_t AccesMode)\n{\n\n    int32_t tmp = 0;\n    uint16_t CANMsg[10]; //Temporary Array to store data to be sent\n    uint16_t *ptrMsg;\n    sEstadoFIFO status = PILA_OK; //Default value\n\n    memset(CANMsg, 0x00, 10); //Set all array to zero for sanity\n\n    ptrMsg = CANMsg;\n\n    if (ptrMsg == NULL) //For sanity, checking pointer\n        return (0x00);  //NULL pointer. Error\n\n    *(ptrMsg++) = Idx_Node;\n\n    if (AccesMode == 0)\n    {\n        *(ptrMsg++) = Diccionario_CanOpen[Idx].Modo_Acceso; //Command Byte (CD), Read,Write operation\n    }\n    else\n    {\n        *(ptrMsg++) = AccesMode; //Command Byte (CD) Read/write operation\n    }\n\n    *(ptrMsg++) = (uint16_t)((Diccionario_CanOpen[Idx].ID) & 0x00FF); //Object Dictionary Index\n    *(ptrMsg++) = (uint16_t)((Diccionario_CanOpen[Idx].ID) >> 8);     //Stored as little endian\n    *(ptrMsg++) = ((Diccionario_CanOpen[Idx].SubIndice));             //Stored SubIndex\n\n    tmp = DataToTx;\n    *(ptrMsg++) = (uint16_t)(tmp & 0x00FF); // Data are saves as little endian\n    tmp = tmp >> 8;\n    *(ptrMsg++) = (uint16_t)(tmp & 0x00FF); // Data are saves little endian\n    tmp = tmp >> 8;\n    *(ptrMsg++) = (uint16_t)(tmp & 0x00FF); // Data are saves little endian\n    tmp = tmp >> 8;\n    *(ptrMsg++) = (uint16_t)(tmp & 0x00FF); // Data are savesas little endian\n\n    ptrMsg = CANMsg; //Restart pointer to first position of buffer\n    memcpy((void *)(ptr_MsgToTx->New_Datos), (void *)(ptrMsg),\n           MSG_DATA_LENGTH + 1); //Message in correct format\n                                 //stored in one item of FIFO struct\n\n    status = Encolar_FIFO(ptr_MsgToTx);\n\n    if (status == PILA_LLENA)\n        return (0x01);\n\n    memset(CANMsg, 0x00, 10); //Reset array to zero for next time\n\n    return (0x01); //All OK\n}\n/**\n * @brief\n * \n * @param Indice_Diccionario_TPO \n * @param ptr_MsgToTx \n * @param DataToTx \n * @param Idx_Node \n * @return uint16_t \n */\nuint16_t Set_CANOpenErrorMsg_To_Tx(enum Indice_Diccionario_TPO Idx,\n                                   FIFO *ptr_MsgToTx, uint32_t DataToTx,\n                                   uint16_t Idx_Node)\n{\n\n    uint32_t tmp = 0;\n    uint16_t CANMsg[10]; //Temporary Array to store data to be sent\n    uint16_t *ptrMsg;\n    sEstadoFIFO status = PILA_OK; //Default value\n\n    memset(CANMsg, 0x00, 10); //Set all array to zero for sanity\n\n    ptrMsg = CANMsg;\n\n    if (ptrMsg == NULL) //For sanity, checking pointer\n        return (0x00);  //NULL pointer. Error\n\n    *(ptrMsg++) = Idx_Node;\n    *(ptrMsg++) = OD_ERROR;                                           //Command Byte (CD), OR_ERROR=0x80\n    *(ptrMsg++) = (uint16_t)((Diccionario_CanOpen[Idx].ID) & 0x00FF); //Object Dictionary Index stored as\n    *(ptrMsg++) = (uint16_t)((Diccionario_CanOpen[Idx].ID) >> 8);     //little endian\n    *(ptrMsg++) = ((Diccionario_CanOpen[Idx].SubIndice));             //Stored SubIndex\n\n    // Data are saves as little endian\n    tmp = DataToTx;\n    *(ptrMsg++) = (uint16_t)(tmp & 0x00FF);\n    tmp = tmp >> 8;\n    *(ptrMsg++) = (uint16_t)(tmp & 0x00FF);\n    tmp = tmp >> 8;\n    *(ptrMsg++) = (uint16_t)(tmp & 0x00FF);\n    tmp = tmp >> 8;\n    *(ptrMsg++) = (uint16_t)(tmp & 0x00FF);\n\n    ptrMsg = CANMsg; //Restart pointer to first position of buffer\n    memcpy((void *)(ptr_MsgToTx->New_Datos), (void *)(ptrMsg),\n           MSG_DATA_LENGTH + 1); //Message in correct format\n                                 //stored in one item of FIFO struct\n\n    status = Encolar_FIFO(ptr_MsgToTx);\n\n    if (status == PILA_LLENA)\n        return (0x01);\n\n    memset(CANMsg, 0x00, 10); //Reset array to zero for next time\n\n    return (0x01); //All OK\n}\n/**\n * @brief Function for transmit message over CAN peripheral\n * \n * @param MsgToTx \n * @return sEstadoFIFO \n */\nsEstadoFIFO Transmit_CANOPenMsg(FIFO MsgToTx)\n{\n    sEstadoFIFO status = PILA_OK; //Variable set to a default value\n    //FIFO *ptr_MsgToTx;\n    //ptr_MsgToTx = &MsgToTx;\n\n    //if (MsgToTx.Estado_PILA != PILA_VACIA) //Are there messages to send?\n    //{\n    //do\n    //{\n    //status = Desencolar_FIFO(&MsgToTx);\n\n    //if ((status == PILA_RESET) || (status == PILA_LLENA)) //TODO: Check these conditions\n    //    return (status);\n    //|------------------FIFO.Datos_Recibidos-------------------|\n    //|---------------------------------------------------------|\n    //| Node_ID      | Modo_Acceso | Object Index | SI | B4-B7  |\n    //|---------------------------------------------------------|\n    //|CAN Struct    |              CAN Struct                  |\n    //|item MsgID    |              CAN item pucMsgData         |\n    //|---------------------------------------------------------|\n    // First direction pointed by *ptr_MsgToTx->Datos_Recibidos\n    // is Node_ID, thus it is post-incremented to point to\n    // Modo_Acceso FIFO item. Then the rest of CANOpen message\n    // datas, included Modo_Acceso, are copied on item putcMsgData\n    // of CAN structure by memcpy() function.\n    //sTX_CANOpenMsg.ui32MsgID = *(ptr_MsgToTx->Datos_Recibidos)++;\n    sTX_CANOpenMsg.ui32MsgID = MsgToTx.Datos_Recibidos[0];\n    sTX_CANOpenMsg.ui32MsgIDMask = 0;\n    sTX_CANOpenMsg.ui32Flags = 0;\n    sTX_CANOpenMsg.ui32MsgLen = MSG_DATA_LENGTH;\n    memcpy(sTX_CANOpenMsg.pucMsgData, MsgToTx.Datos_Recibidos + 1,\n           MSG_DATA_LENGTH);\n    //TODO: Add condition to check that, \"Not send a new CAN frame\n    //if no exit a previously succes tx\"\n    CANMessageSet(CANA_BASE, 1, &sTX_CANOpenMsg, MSG_OBJ_TYPE_TX);\n    while (CanaRegs.CAN_ES.bit.TxOk != 0x01)\n    {\n        //CanaRegs.CAN_ES.bit.TxOk\n    }; //Wait until CAN tx finish\n        //DELAY_US(6000);\n        //Start CAN tx timeOut exception\n    StatusCom.StatusFlags.Flags.TransmittedCanMsg = 1;\n    //TODO: Check if we shall put a delay() instead of while (...)\n\n    // } while (MsgToTx.Msg_pendientes != 0);\n    //}\n    //else\n    return (status);\n}\n/**\n * @brief Create mailbox for Power Supply\n * \n */\nvoid Set_MailboxOne(void)\n{\n\n    sMailboxOneCANOpenMsg.ui32MsgID = TSDO + PS_NODE_ID;\n    sMailboxOneCANOpenMsg.ui32MsgIDMask = 0x1FFFFFFF;\n    sMailboxOneCANOpenMsg.ui32Flags = MSG_OBJ_RX_INT_ENABLE | MSG_OBJ_USE_ID_FILTER;\n    sMailboxOneCANOpenMsg.ui32MsgLen = MSG_DATA_LENGTH;\n    sMailboxOneCANOpenMsg.pucMsgData = rxPsMsgData;\n    CANMessageSet(CANA_BASE, MAILBOX_ONE, &sMailboxOneCANOpenMsg,\n                  MSG_OBJ_TYPE_RX);\n}\n/**\n * @brief Create mailbox for ADC\n * \n */\nvoid Set_MailboxTwo(void)\n{\n\n    sMailboxTwoCANOpenMsg.ui32MsgID = RSDO + COM_NODE_ID;\n    sMailboxTwoCANOpenMsg.ui32MsgIDMask = 0x1FFFFFFF;\n    sMailboxTwoCANOpenMsg.ui32Flags = MSG_OBJ_RX_INT_ENABLE | MSG_OBJ_USE_ID_FILTER;\n    sMailboxTwoCANOpenMsg.ui32MsgLen = MSG_DATA_LENGTH;\n    sMailboxTwoCANOpenMsg.pucMsgData = rxAdcMsgData;\n    CANMessageSet(CANA_BASE, MAILBOX_TWO, &sMailboxTwoCANOpenMsg,\n                  MSG_OBJ_TYPE_RX);\n}\n\n/**\n * @brief Enable ADC PCB sending CAN message \n * \n */\nuint16_t InitAdc(void)\n{\n    static uint16_t stateInitAdc = 0;\n    uint16_t status = 0x01; //By default all ok\n    enum OD_Index;\n\n    switch (stateInitAdc)\n    {\n    case 0:\n        OD_Index = Config_ADC; //CAN command array Index. Commands present in Diccionario_CANOpen.c file\n        status = Set_CANOpenMsg_To_Tx(OD_Index, &FIFO_CanTx, ENABLE_ADC,\n                                      RSDO + ADC_NODE_ID,\n                                      0);\n        if (FIFO_CanTx.Estado_PILA != PILA_VACIA)\n        {\n            status = Desencolar_FIFO(&FIFO_CanTx);\n            Transmit_CANOPenMsg(FIFO_CanTx);\n        }\n        stateInitAdc = 1;\n        break;\n\n    case 1: //Check if we have a TimeOut reception from PS, if so,\n        //set an error\n        if (StatusCom.StatusFlags.Flags.DataAvailable)\n        {\n            stateInitAdc = 2;\n        }\n        else if (StatusCom.StatusFlags.Flags.ErrorCom)\n        {\n            //TODO: Set an error flag, stop everything and display it in user interface\n        }\n        break;\n\n    case 2: //No TimeOut reception from PS, then analyze CAN message received\n        //AnalyzeCanMsg();\n        if (AdcValuesSaved.StatusFlags.Flags.VoltageAnswerFromAdc)\n        {\n            AdcValuesSaved.StatusFlags.Flags.VoltageAnswerFromAdc = false;\n            stateInitAdc = 2;\n        }\n        else if (AdcValuesSaved.StatusFlags.Flags.CurrentAnswerFromAdc)\n        {\n            AdcValuesSaved.StatusFlags.Flags.CurrentAnswerFromAdc = false;\n            stateInitAdc = 3;\n        }\n        else\n        {\n            //TODO: Set an error flag, stop everything and display it in user interface\n            return (0x00);\n        }\n        break;\n\n    case 3:\n        //All ok\n        stateInitAdc = 0;\n        status = 0x01;\n        break;\n\n    default:\n        //TODO: Set an error flag, stop everything and display it in user interface\n        status = 0x00;\n        break;\n    }\n    return (status);\n}\n/**\n * @brief Initialize Power Supply. First check communication with PowerSuply,\n *        then set current/voltage to zero, finally save those values on two\n *        variables\n *\n * @return uint16_t \n */\nuint16_t InitPowerSupply(void)\n{\n    static uint16_t stateInitPs = 0;\n    uint16_t status = 0x01; //By default all ok\n    enum OD_Index;\n\n    switch (stateInitPs)\n    {\n    case 0: //Send a Device Name CAN message to test communication with PS\n        PsEnable_ON();\n        OD_Index = Nombre_dispositivo;\n        status = Set_CANOpenMsg_To_Tx(OD_Index, &FIFO_CanTx, 0,\n                                      RSDO + PS_NODE_ID,\n                                      OD_READ_2BYTES);\n        if (FIFO_CanTx.Estado_PILA != PILA_VACIA)\n        {\n            status = Desencolar_FIFO(&FIFO_CanTx);\n            Transmit_CANOPenMsg(FIFO_CanTx);\n        }\n        stateInitPs = 1;\n        break;\n\n    case 1: //Check if we have a TimeOut reception from PS, if so,\n        //set an error\n        if (StatusCom.StatusFlags.Flags.DataAvailable)\n        {\n            StatusCom.StatusFlags.Flags.DataAvailable = false;\n            stateInitPs = 2;\n        }\n        else if (StatusCom.StatusFlags.Flags.ErrorCom)\n        {\n            //TODO: Set an error flag, stop everything and display it in user interface\n            status = 0x00;\n        }\n        break;\n\n    case 2: //No TimeOut reception from PS, then analyze CAN message received\n        //AnalyzeCanMsg();\n        if ((OD_Index == Nombre_dispositivo) && (PowerSupplyValues.StatusFlags.Flags.AnswerDeviceName))\n        {\n            //Correct CAN message received\n            PowerSupplyValues.StatusFlags.Flags.AnswerDeviceName = false;\n            stateInitPs = 3;\n        }\n        else if ((OD_Index == Udc_Out_Setpoint) && (PowerSupplyValues.StatusFlags.Flags.AnswerVSet))\n        {\n            PowerSupplyValues.StatusFlags.Flags.AnswerVSet = false;\n            stateInitPs = 4;\n        }\n        else if ((OD_Index == Idc_Out_Setpoint) && (PowerSupplyValues.StatusFlags.Flags.AnswerISet))\n        {\n            PowerSupplyValues.StatusFlags.Flags.AnswerISet = false;\n            stateInitPs = 5;\n        }\n        break;\n\n    case 3: //Next set V to zero values, just in case\n        OD_Index = Udc_Out_Setpoint;\n        status = Set_CANOpenMsg_To_Tx(OD_Index, &FIFO_CanTx, 0x0000F401,\n                                      RSDO + PS_NODE_ID,\n                                      OD_WRITE_2BYTES);\n        if (FIFO_CanTx.Estado_PILA != PILA_VACIA)\n        {\n            status = Desencolar_FIFO(&FIFO_CanTx);\n            Transmit_CANOPenMsg(FIFO_CanTx);\n        }\n        stateInitPs = 1;\n        break;\n\n    case 4: //Next set I to zero values, just in case\n        OD_Index = Idc_Out_Setpoint;\n        status = Set_CANOpenMsg_To_Tx(OD_Index, &FIFO_CanTx, 0,\n                                      RSDO + PS_NODE_ID,\n                                      OD_WRITE_2BYTES);\n        if (FIFO_CanTx.Estado_PILA != PILA_VACIA)\n        {\n            status = Desencolar_FIFO(&FIFO_CanTx);\n            Transmit_CANOPenMsg(FIFO_CanTx);\n        }\n        stateInitPs = 1;\n        break;\n\n    case 5:\n        PowerSupplyValues.ActualCurrentValue = 0x0000F401;\n        PowerSupplyValues.ActualVoltageValue = 0;\n        PowerSupplyValues.PowerModuleStatus = 0x01; //Charger ON\n        stateInitPs = 0;\n        status = 0X01;\n        break;\n\n    default:\n        //TODO: Set an error flag, stop everything and display it in user interface\n        status = 0x00;\n        break;\n    }\n\n    return (status);\n}\n/*\n * @brief Set voltage from power supply to desired value \n * \n * @param VoltageRequest \n * @return uint16_t \n */\nuint16_t PsSetVoltageCurrent(uint16_t VoltageRequest, int16_t CurrentRequest,\n                             bool EnablePs)\n{\n    static uint16_t stateSetPsVI = 0;\n    uint16_t status = 0x01; //By default all ok\n    uint16_t tmpVoltageValue = 0;\n    int16_t tmpCurrentValue = 0;\n    static uint16_t CounterVoltageIterations = 9;\n    static uint16_t CounterCurrentIterations = 9;\n    float SlopeVoltage = 0.0;\n    float SlopeCurrent = 0.0;\n    enum OD_Index;\n\n    switch (stateSetPsVI)\n    {\n    case 0: //Send a Device Name CAN message to test communication with PS\n        //this CAN message is also used as keep alive frame\n        if (EnablePs == false)\n        {\n            PsEnable_OFF();\n            stateSetPsVI = 0;\n            break;\n        }\n        else if (EnablePs == true)\n        {\n            PsEnable_ON();\n        }\n        OD_Index = Nombre_dispositivo;\n        status = Set_CANOpenMsg_To_Tx(OD_Index, &FIFO_CanTx, 0,\n                                      RSDO + PS_NODE_ID,\n                                      OD_WRITE_2BYTES);\n        Transmit_CANOPenMsg(FIFO_CanTx);\n        stateSetPsVI = 1;\n        break;\n\n    case 1: //Check if we have a TimeOut reception from PS, if so,\n        //set an error\n        if (StatusCom.StatusFlags.Flags.DataAvailable)\n        {\n            stateSetPsVI = 2;\n        }\n        else if (StatusCom.StatusFlags.Flags.ErrorCom)\n        {\n            //TODO: Set an error flag, stop everything and display it in user interface\n            return (0x00);\n        }\n        break;\n\n    case 2: //No TimeOut reception from PS, then analyze CAN message received\n        //AnalyzeCanMsg();\n        if ((OD_Index == Nombre_dispositivo) && (PowerSupplyValues.StatusFlags.Flags.AnswerDeviceName))\n        {\n            //Correct CAN message received\n            PowerSupplyValues.StatusFlags.Flags.AnswerDeviceName = false;\n            stateSetPsVI = 3;\n        }\n        else if ((OD_Index == Udc_Out_Setpoint) && (PowerSupplyValues.StatusFlags.Flags.AnswerVSet))\n        {\n            PowerSupplyValues.StatusFlags.Flags.AnswerVSet = false;\n            stateSetPsVI = 4;\n        }\n        else if ((OD_Index == Idc_Out_Setpoint) && (PowerSupplyValues.StatusFlags.Flags.AnswerISet))\n        {\n            PowerSupplyValues.StatusFlags.Flags.AnswerISet = false;\n            stateSetPsVI = 5;\n        }\n        break;\n\n    case 3: //Analize desired current/voltage values. If they are different from previous\n        //current/voltage values, then calculate necessary values to ramp up/down\n        //and go to next state. If not, go to first state and send keep alive frame every 500ms\n\n        /* if (VoltageRequest < 0) //Not possible. but just in case\n         {\n         //TODO: Set an error flag, stop everything and display it in user interface\n         status=0x00;\n         break;\n         }*/\n        if (VoltageRequest != PowerSupplyValues.ActualVoltageValue)\n        {\n            if ( > V2G500V15A_VOLTAGE)\n            {\n                //Maximum value allowed\n                 = V2G500V15A_VOLTAGE;\n            }\n            //Linear Interpolation. We calculate slope as:\n            //Slope = ((Requested Value - Actual Values) / Seconds to ramp up/down)\n            //Function, PsSetVoltageCurrent() is triggered every 500ms using our scheduler,\n            //then after all iterations has been executed, ramp up or down process will have\n            //lasted four seconds. Total number of steps-iteration = 8, each\n            //step-iteration take 500ms.\n            SlopeVoltage = (( - PowerSupplyValues.ActualVoltageValue) /\n                            LENGHT_SECONDS_RAMP); // slope V/s\n            CounterVoltageIterations = 0;\n            stateSetPsVI = 4;\n        }\n\n        else if (CurrentRequest != PowerSupplyValues.ActualCurrentValue)\n        {\n            if ((CurrentRequest & 0x80000000) == 0x80000000)\n            {\n                //Negative current\n                if (CurrentRequest < -(V2G500V15A_VOLTAGE))\n                {\n                    //Maximum value allowed\n                    CurrentRequest = -(V2G500V15A_CURRENT);\n                }\n            }\n            else\n            {\n                //Positive current\n                if (CurrentRequest > V2G500V15A_VOLTAGE)\n                {\n                    //Maximum value allowed\n                    CurrentRequest = V2G500V15A_CURRENT;\n                }\n            }\n            //Linear Interpolation. We calculate slope as:\n            //Slope = ((Requested Value - Actual Values) / Total step-iteration)\n            //Total steps-iteration = 8, each step-iteration take 500ms.\n            //Function, PsSetVoltageCurrent() is triggered every 500ms using our scheduler,\n            //then after all iterations has been executed, ramp up or down process will have\n            //lasted four seconds\n            SlopeCurrent = ((CurrentRequest - PowerSupplyValues.ActualCurrentValue) /\n                            LENGHT_SECONDS_RAMP); // slope V/I\n            CounterCurrentIterations = 0;\n            stateSetPsVI = 4;\n        }\n        else if (( == PowerSupplyValues.ActualVoltageValue) && (CurrentRequest == PowerSupplyValues.ActualCurrentValue))\n        {\n            //No changes on V/I to be done, then go to case 0 and send keep alive frame\n            stateSetPsVI = 0;\n        }\n        break;\n\n    case 4: //Send new values of voltage\n        if (CounterVoltageIterations < 7)\n        {\n            //Start increment voltage. First 7 iterations\n            tmpVoltageValue =\n                (PowerSupplyValues.ActualVoltageValue + ((CounterVoltageIterations * MS_STEP_RAMP) * SlopeVoltage));\n            OD_Index = Udc_Out_Setpoint;\n            status = Set_CANOpenMsg_To_Tx(OD_Index, &FIFO_CanTx,\n                                          tmpVoltageValue,\n                                          RSDO + PS_NODE_ID,\n                                          OD_WRITE_2BYTES);\n            Transmit_CANOPenMsg(FIFO_CanTx);\n            CounterVoltageIterations++;\n            stateSetPsVI = 1;\n        }\n        else if (CounterVoltageIterations == 7)\n        {\n            //Last iteration, we set the final values as value requested by system\n            OD_Index = Udc_Out_Setpoint;\n            status = Set_CANOpenMsg_To_Tx(OD_Index, &FIFO_CanTx, ,\n                                          RSDO + PS_NODE_ID,\n                                          OD_WRITE_2BYTES);\n            Transmit_CANOPenMsg(FIFO_CanTx);\n            CounterVoltageIterations++;\n            stateSetPsVI = 1;\n        }\n        else if (CounterVoltageIterations == 8)\n        {\n            //Finished ramp up/down for voltage, reset step-iterations counter\n            //and go to ramp up/dowm for current\n            CounterVoltageIterations = 9;\n            stateSetPsVI = 5;\n        }\n        break;\n\n    case 5: //Send new values of current\n\n        if (CounterCurrentIterations < 7)\n        {\n            tmpCurrentValue =\n                (PowerSupplyValues.ActualCurrentValue + ((CounterCurrentIterations * MS_STEP_RAMP) * SlopeCurrent));\n            OD_Index = Idc_Out_Setpoint;\n            status = Set_CANOpenMsg_To_Tx(OD_Index, &FIFO_CanTx,\n                                          tmpCurrentValue,\n                                          RSDO + PS_NODE_ID,\n                                          OD_WRITE_2BYTES);\n            Transmit_CANOPenMsg(FIFO_CanTx);\n            CounterVoltageIterations++;\n            stateSetPsVI = 1;\n        }\n        else if (CounterCurrentIterations == 7)\n        {\n            //Last iteration, we set the final values as value requested by system\n            OD_Index = Idc_Out_Setpoint;\n            status = Set_CANOpenMsg_To_Tx(OD_Index, &FIFO_CanTx, CurrentRequest,\n                                          RSDO + PS_NODE_ID,\n                                          OD_WRITE_2BYTES);\n            Transmit_CANOPenMsg(FIFO_CanTx);\n            CounterCurrentIterations = 8;\n            stateSetPsVI = 1;\n        }\n        else if (CounterCurrentIterations == 8)\n        {\n            //Finished ramp up/down for current, reset step-iteration conter\n            //and go to next state to save final values\n            CounterCurrentIterations = 9;\n            stateSetPsVI = 6;\n        }\n        break;\n\n    case 6:\n        PowerSupplyValues.ActualCurrentValue = CurrentRequest;\n        PowerSupplyValues.ActualVoltageValue = VoltageRequest;\n        stateSetPsVI = 0;\n        status = 0X01;\n        break;\n\n    default:\n        //TODO: Set an error flag, stop everything and display it in user interface\n        status = 0x00;\n        break;\n    }\n\n    return (status);\n}\n/**\n * @brief \n * \n */\nvoid Scheduler(void)\n{\n    uint16_t status = 0x01; //By default all ok\n\n    Count1ms++;\n    //Every 10ms\n    TimeOutRxCanMsg();\n    if(Count10ms >=10)\n    {\n        Count10ms=0;\n        Count20ms++\n        TimeOutRxCanMsg();\n    }\n    //Check others timers\n    if (Count20ms >= 2)\n    {\n        Count20ms = 0;\n        Count50ms++;\n        //Every 20ms\n        if ((StatusCom.StatusFlags.Flags.ErrorCom != true) && (FIFO_CanRx.Estado_PILA != PILA_VACIA))\n        {\n            //No timeout in Rx and there are data on FIFO Rx to analyze\n            AnalyzeCanMsg();\n        }\n    }\n    if (Count50ms == 3 )\n    {\n        Count20ms = 0;\n        Count100ms++;\n        //Every 100ms\n        if (PowerSupplyValues.PowerModuleStatus != 0x01)\n        {\n            //Power Supply OFF. This sentence execute only once.\n            //Check com. with power supply and set values\n            status = InitPowerSupply();\n        }\n    }\n    if (Count50ms ==  )\n    {\n\n    }\n    if (Count100ms >= 5)\n    {\n        Count100ms = 0;\n        Count500ms++;\n        //Every 500ms\n    }\n    if (Count500ms >= 2)\n    {\n        Count500ms = 0;\n        Count1s++;\n        //Every 1s\n        \n    }\n    if (Count1s >= 2)\n    {\n        Count1s = 0;\n        Count5s++;\n        //Every 5s\n    }\n    if (Count5s >= 2)\n    {\n        Count5s = 0;\n        //Every 10s\n    }\n}\n/**\n * @brief \n * \n */\nvoid TimeOutRxCanMsg(void)\n{\n    if ((StatusCom.StatusFlags.Flags.TransmittedCanMsg == true) && (StatusCom.StatusFlags.Flags.DataAvailable != true))\n    {\n        ulTimeOutCANRx++;\n        if (ulTimeOutCANRx == TIMEOUT_CAN_RX)\n        {\n            StatusCom.StatusFlags.Flags.TransmittedCanMsg = false;\n            StatusCom.StatusFlags.Flags.DataAvailable = false;\n            StatusCom.StatusFlags.Flags.ErrorCom = true;\n            ulTimeOutCANRx = 0;\n        }\n    }\n}\n/*-----------------------------------END MISCELANIOUS FUNCTIONS--------------------------------------*/\n\n/*----------------------------------BEGIN CONTROL LOGIC FUNCTIONS------------------------------------*/\n/**\n * @brief\n * \n */\nvoid AnalyzeCanMsg(void)\n{\n    uint16_t SubIndex = 0; //Temporal variable to save SubIndex\n    uint16_t ObjIndex = 0; //Temporal variable to save Object Index\n    uint16_t AccessMode = 0;\n    uint16_t DataSaved[9] = {0x00}; //Temporal array where store data received from CAN\n    uint32_t TmpValue = 0;          //\n    uint16_t DictionaryIndex = 0;   //Temporal variable used for check ObjectIndex\n                                    //and AccesCmd\n    uint16_t NodeIdRx = 0;          //Temporal variable to store Id from node transmitter\n\n    //TODO: Check this\n    //memset(DataSaved, 0x00, 9); //Reset array to zero\n\n    Desencolar_FIFO(&FIFO_CanRx);\n    //Move data from FIFO to variable DataSaved for post-processing\n    memcpy((void *)DataSaved, (void *)FIFO_CanRx.Datos_Recibidos, 9);\n\n    NodeIdRx = (uint16_t)DataSaved[0];\n    AccessMode = (uint16_t)DataSaved[1];\n    ObjIndex = (uint16_t)DataSaved[2] + (uint16_t)(DataSaved[3] << 8);\n    SubIndex = (uint16_t)DataSaved[4];\n    //AdcValue = datos_char_to_int(DataSaved[5]);\n    TmpValue = (uint32_t)DataSaved[8] << 24;\n    TmpValue += (uint32_t)DataSaved[7] << 16;\n    TmpValue += (uint32_t)DataSaved[6] << 8;\n    TmpValue += (uint32_t)DataSaved[5];\n\n    DictionaryIndex = Econtrar_Indice_Diccionario(ObjIndex, SubIndex);\n\n    if (DictionaryIndex == FIN_Diccionario)\n    {\n        // Requested Object index doesn´t exit, then set flag error and tx Error CAN msg\n        StatusErrors.StatusFlags.Flags.ObjectIndexError = true;\n        Set_CANOpenErrorMsg_To_Tx(DictionaryIndex, &FIFO_CanTx, 0x00,\n                                  RSDO + NodeIdRx);\n    }\n    else\n    {\n        // Requested Object index received exist\n        if (Diccionario_CanOpen[DictionaryIndex].Modo_Acceso == AccessMode) //TODO: Check if necessary this condition\n        {\n            // Requested Access mode for that Object index exist\n            if ((AccessMode >= OD_READ) && (AccessMode <= OD_READ_4BYTES))\n            {\n                StatusCom.StatusFlags.Flags.AccessModeRead = true;\n                StatusCom.StatusFlags.Flags.AccessModeWrite = false;\n            }\n            else if ((AccessMode >= OD_WRITE) && (AccessMode <= OD_WRITE_4BYTES))\n            {\n                StatusCom.StatusFlags.Flags.AccessModeRead = false;\n                StatusCom.StatusFlags.Flags.AccessModeWrite = true;\n            }\n            else if ((AccessMode >= OD_WRITE + OD_READ) && (AccessMode <= OD_WRITE_4BYTES + OD_READ_4BYTES))\n            {\n                StatusCom.StatusFlags.Flags.AccessModeRead = true;\n                StatusCom.StatusFlags.Flags.AccessModeWrite = true;\n            }\n            //TODO: Check  Access Command Error 0x80\n            else\n            {\n                //Requested Access Mode doesn´t exit, then set flag error and tx Error CAN msg\n                StatusErrors.StatusFlags.Flags.AccessCmdError = true;\n                Set_CANOpenErrorMsg_To_Tx(DictionaryIndex, &FIFO_CanTx, 0x00,\n                                          RSDO + NodeIdRx);\n                //TODO: No transmission done, only set CAN error frame\n            }\n        }\n    }\n\n    switch (ObjIndex)\n    {\n    case 0x9000: // Get Voltage/Current values from ADC\n\n        if (SubIndex == 0x00) //Vout from ADC\n        {\n            //Request Access Mode correct\n            if (StatusCom.StatusFlags.Flags.AccessModeRead)\n            {\n                //Do nothing\n            }\n            else if (StatusCom.StatusFlags.Flags.AccessModeWrite)\n            {\n                AdcValuesSaved.VoltageValue = TmpValue;                     //Raw value for Chademo logic\n                AdcValuesSaved.floatVolatageValue = (float)TmpValue / 10.0; //0.1 A/bit\n                AdcValuesSaved.StatusFlags.Flags.VoltageAnswerFromAdc =\n                    true;\n            }\n            else if ((StatusCom.StatusFlags.Flags.AccessModeRead) && ((StatusCom.StatusFlags.Flags.AccessModeWrite)))\n            {\n                //Do nothing\n            }\n        }\n        else\n        {\n            //Requested Access Mode incorrect, send an error message to the transmitter\n            StatusErrors.StatusFlags.Flags.AccessCmdError = true;\n            Set_CANOpenErrorMsg_To_Tx(DictionaryIndex, &FIFO_CanTx, 0x00,\n                                      RSDO + NodeIdRx);\n        }\n        if (SubIndex == 0x01) //Iout from ADC\n        {\n\n            //Request Access Mode correct\n            if (StatusCom.StatusFlags.Flags.AccessModeRead)\n            {\n                //Do nothing\n            }\n            else if (StatusCom.StatusFlags.Flags.AccessModeWrite)\n            {\n                AdcValuesSaved.CurrentValue = TmpValue; //Raw value for Chademo logic\n                //Get sign of the Current Value\n                if ((AdcValuesSaved.CurrentValue & 0x80000000) == 0x80000000)\n                {\n                    AdcValuesSaved.NegativeCurrentValue = true; //Negative number\n                    // If it is negative, make it positive by inverting the bits\n                    // and adding one.\n                    TmpValue = ~TmpValue; //Bitwise negation of all bits\n                    TmpValue += 0x01;\n                }\n                else\n                {\n                    AdcValuesSaved.NegativeCurrentValue = false; //No negative number\n                }\n                //AdcValuesSaved.floatCurrentValue = (float)TmpValue / 10.0; //0.1 A/bit\n                AdcValuesSaved.StatusFlags.Flags.CurrentAnswerFromAdc =\n                    true;\n            }\n            else if ((StatusCom.StatusFlags.Flags.AccessModeRead) && ((StatusCom.StatusFlags.Flags.AccessModeWrite)))\n            {\n                //Do nothing\n            }\n        }\n        else\n        {\n            //Requested Access Mode incorrect, send an error message to the transmitter\n            StatusErrors.StatusFlags.Flags.AccessCmdError = true;\n            Set_CANOpenErrorMsg_To_Tx(DictionaryIndex, &FIFO_CanTx, 0x00,\n                                      RSDO + NodeIdRx);\n        }\n        break;\n\n    case 0x1008: //Power Supply Device Name\n\n        if (SubIndex == 0x04)\n        {\n            //Check answer from Power Supply. \"V2G500V15A\" model return the string \"_V2G\"\n            if (TmpValue == 0x47325620) //Chars values of string \"G2V_\", little-endian of \"_V2G\"\n            {\n                PowerSupplyValues.StatusFlags.Flags.AnswerDeviceName = true;\n            }\n            else\n            {\n                PowerSupplyValues.StatusFlags.Flags.AnswerDeviceNameError =\n                    false;\n            }\n        }\n        else\n        {\n            StatusErrors.StatusFlags.Flags.SubIndexError = true;\n        }\n        break;\n\n    case 0x2109: //Output voltage set point\n\n        if (SubIndex == 0x00)\n        {\n            if (AccessMode == 0x60)\n            {\n                PowerSupplyValues.StatusFlags.Flags.AnswerVSet = true;\n            }\n        }\n        break;\n\n    case 0x210A: //Output current set point\n\n        if (SubIndex == 0x00)\n        {\n            if (AccessMode == 0x60)\n            {\n                PowerSupplyValues.StatusFlags.Flags.AnswerISet = true;\n            }\n        }\n        break;\n\n    default:\n        StatusErrors.StatusFlags.Flags.ObjectIndexError = true;\n        Set_CANOpenErrorMsg_To_Tx(DictionaryIndex, &FIFO_CanTx, 0x00,\n                                  RSDO + NodeIdRx);\n        break;\n    }\n}\n/*  END CONTROL LOGIC FUNCTIONS */\n",
			"file": "COM_cpu01/App/ComModule.c",
			"file_size": 36813,
			"file_write_time": 131868425965378155,
			"settings":
			{
				"buffer_size": 35732,
				"line_ending": "Windows"
			}
		},
		{
			"file": "F2837xD/Comun/Drivers/Init_HW.c",
			"settings":
			{
				"buffer_size": 3335,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"contr",
				"Package Control: Install Package"
			],
			[
				"packa",
				"Package Control: Remove Package"
			],
			[
				"Inst",
				"Package Control: Install Package"
			],
			[
				"inst",
				"Package Control: Install Package"
			],
			[
				"install",
				"Package Control: Install Package"
			],
			[
				"insta",
				"Package Control: Install Package"
			]
		],
		"width": 0.0
	},
	"console":
	{
		"height": 0.0,
		"history":
		[
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/C/Users/dagaro/workspace/Firmware_Test/UFCharger",
		"/C/Users/dagaro/workspace/Firmware_Test/UFCharger/COM_cpu01",
		"/C/Users/dagaro/workspace/Firmware_Test/UFCharger/COM_cpu01/App",
		"/C/Users/dagaro/workspace/Firmware_Test/UFCharger/F2837xD",
		"/C/Users/dagaro/workspace/Firmware_Test/UFCharger/F2837xD/Comun",
		"/C/Users/dagaro/workspace/Firmware_Test/UFCharger/F2837xD/Comun/Drivers"
	],
	"file_history":
	[
		"/C/Users/dagaro/workspace/Firmware_Test/UFCharger/COM_cpu01/main_cpu1.c",
		"/C/Users/dagaro/workspace/Firmware_Test/UFCharger/F2837xD/Comun/Drivers/Config_CAN.c",
		"/C/Users/dagaro/workspace/Firmware_Test/UFCharger/F2837xD/Comun/Drivers/Include/FIFO.h",
		"/C/Users/dagaro/workspace/Firmware_Test/UFCharger/F2837xD/Comun/driverlib/can.h",
		"/C/Sublime Text Build 3176/Data/Packages/Function Name Display/Function Name Display.sublime-settings",
		"/C/Sublime Text Build 3176/Data/Packages/WhoCalled Function Finder/README.md",
		"/C/Sublime Text Build 3176/Data/Packages/Clang Format/Default (Windows).sublime-keymap",
		"/C/Sublime Text Build 3176/Data/Packages/Clang Format/clang_format.sublime-settings"
	],
	"find":
	{
		"height": 27.0
	},
	"find_in_files":
	{
		"height": 0.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"VoltageRequest",
			";\n",
			"stateInitPs",
			"case",
			"OD_Index"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 0,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "COM_cpu01/App/ComModule.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 35732,
						"regions":
						{
						},
						"selection":
						[
							[
								20494,
								20494
							],
							[
								20587,
								20587
							],
							[
								21099,
								21099
							],
							[
								22650,
								22650
							],
							[
								23863,
								23863
							]
						],
						"settings":
						{
							"function_name_status_row": 581,
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "F2837xD/Comun/Drivers/Init_HW.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3335,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"function_name_status_row": 80,
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1130.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 27.0
	},
	"input":
	{
		"height": 0.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.find_results":
	{
		"height": 0.0
	},
	"pinned_build_system": "",
	"project": "Test_sublime_workspace.sublime-project",
	"replace":
	{
		"height": 50.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 249.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
